# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-monads` gem.
# Please instead update this file by running `bin/tapioca gem dry-monads`.

# Inspired by standard library implementation
# for Time serialization/deserialization see (json/lib/json/add/time.rb)
#
# source://dry-monads//lib/dry/monads/constants.rb#3
module Dry
  class << self
    # source://dry-cli/1.0.0/lib/dry/cli.rb#221
    def CLI(registry_or_command = T.unsafe(nil), &block); end

    # source://dry-core/1.0.1/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end
  end
end

# Common, idiomatic monads for Ruby
#
# @api public
#
# source://dry-monads//lib/dry/monads/constants.rb#4
module Dry::Monads
  include ::Dry::Core::Constants
  extend ::Dry::Monads::Result::Mixin::Constructors
  extend ::Dry::Monads::Maybe::Mixin::Constructors
  extend ::Dry::Monads::Validated::Mixin::Constructors
  extend ::Dry::Monads::Try::Mixin::Constructors
  extend ::Dry::Monads::Lazy::Mixin::Constructors
  extend ::Dry::Monads::Task::Mixin::Constructors

  class << self
    # Creates a module that has two methods: `Success` and `Failure`.
    # `Success` is identical to {Result::Mixin::Constructors#Success} and Failure
    # rejects values that don't conform the value of the `error`
    # parameter. This is essentially a Result type with the `Failure` part
    # fixed.
    #
    # @api private
    # @example using dry-types
    #   module Types
    #   include Dry::Types.module
    #   end
    #
    #   class Operation
    #   # :user_not_found and :account_not_found are the only
    #   # values allowed as failure results
    #   Error =
    #   Types.Value(:user_not_found) |
    #   Types.Value(:account_not_found)
    #
    #   include Dry::Monads::Result(Error)
    #
    #   def find_account(id)
    #   account = acount_repo.find(id)
    #
    #   account ? Success(account) : Failure(:account_not_found)
    #   end
    #
    #   def find_user(id)
    #   # ...
    #   end
    #   end
    # @param error [#===] the type of allowed failures
    # @return [Module]
    #
    # source://dry-monads//lib/dry/monads/result.rb#397
    def Result(error, **options); end

    # Build a module with cherry-picked monads.
    # It saves a bit of typing when you add multiple
    # monads to one class. Not loaded monads get loaded automatically.
    #
    # @api public
    # @example
    #   require 'dry/monads'
    #
    #   class CreateUser
    #   include Dry::Monads[:result, :do]
    #
    #   def initialize(repo, send_email)
    #   @repo = repo
    #   @send_email = send_email
    #   end
    #
    #   def call(name)
    #   if @repo.user_exist?(name)
    #   Failure(:user_exists)
    #   else
    #   user = yield @repo.add_user(name)
    #   yield @send_email.(user)
    #   Success(user)
    #   end
    #   end
    #   end
    # @param monads [Array<Symbol>]
    # @return [Module]
    #
    # source://dry-monads//lib/dry/monads.rb#68
    def [](*monads); end

    # @api public
    # @private
    # @private
    #
    # source://dry-monads//lib/dry/monads.rb#31
    def included(base); end

    # @api private
    #
    # source://dry-monads//lib/dry/monads.rb#16
    def loader; end

    protected

    # @api private
    #
    # source://dry-monads//lib/dry/monads/registry.rb#30
    def registry=(registry); end

    private

    # @api private
    # @private
    # @return [Boolean]
    #
    # source://dry-monads//lib/dry/monads/registry.rb#68
    def all_loaded?; end

    # @api private
    # @private
    #
    # source://dry-monads//lib/dry/monads/registry.rb#61
    def constructors; end

    # @api private
    # @private
    #
    # source://dry-monads//lib/dry/monads/registry.rb#46
    def known_monads; end

    # @api private
    # @private
    #
    # source://dry-monads//lib/dry/monads/registry.rb#51
    def load_monad(name); end

    # @api private
    # @private
    #
    # source://dry-monads//lib/dry/monads/registry.rb#37
    def register_mixin(name, mod); end

    # @api private
    #
    # source://dry-monads//lib/dry/monads/registry.rb#28
    def registry; end
  end
end

# Improper use of None
#
# source://dry-monads//lib/dry/monads/errors.rb#23
class Dry::Monads::ConstructorNotAppliedError < ::NoMethodError
  # @return [ConstructorNotAppliedError] a new instance of ConstructorNotAppliedError
  #
  # source://dry-monads//lib/dry/monads/errors.rb#24
  def initialize(method_name, constructor_name); end
end

# source://dry-monads//lib/dry/monads/conversion_stubs.rb#5
module Dry::Monads::ConversionStubs
  class << self
    # source://dry-monads//lib/dry/monads/conversion_stubs.rb#6
    def [](*method_names); end
  end
end

# source://dry-monads//lib/dry/monads/conversion_stubs.rb#16
module Dry::Monads::ConversionStubs::Methods
  private

  # source://dry-monads//lib/dry/monads/conversion_stubs.rb#19
  def to_maybe; end

  # source://dry-monads//lib/dry/monads/conversion_stubs.rb#23
  def to_result; end

  # source://dry-monads//lib/dry/monads/conversion_stubs.rb#27
  def to_validated; end

  class << self
    # source://dry-monads//lib/dry/monads/conversion_stubs.rb#19
    def to_maybe; end

    # source://dry-monads//lib/dry/monads/conversion_stubs.rb#23
    def to_result; end

    # source://dry-monads//lib/dry/monads/conversion_stubs.rb#27
    def to_validated; end
  end
end

# @private
#
# source://dry-monads//lib/dry/monads/curry.rb#6
module Dry::Monads::Curry
  class << self
    # @private
    #
    # source://dry-monads//lib/dry/monads/curry.rb#8
    def call(value); end
  end
end

# An implementation of do-notation.
#
# @see Do.for
#
# source://dry-monads//lib/dry/monads/do.rb#8
module Dry::Monads::Do
  extend ::Dry::Monads::Do::Mixin
  include ::Dry::Monads::Do::All

  class << self
    # @api private
    #
    # source://dry-monads//lib/dry/monads/do.rb#149
    def coerce_to_monad(monads); end

    # Generates a module that passes a block to methods
    # that either unwraps a single-valued monadic value or halts
    # the execution.
    #
    # @example A complete example
    #
    #   class CreateUser
    #   include Dry::Monads::Result::Mixin
    #   include Dry::Monads::Try::Mixin
    #   include Dry::Monads::Do.for(:call)
    #
    #   attr_reader :user_repo
    #
    #   def initialize(:user_repo)
    #   @user_repo = user_repo
    #   end
    #
    #   def call(params)
    #   json = yield parse_json(params)
    #   hash = yield validate(json)
    #
    #   user_repo.transaction do
    #   user = yield create_user(hash[:user])
    #   yield create_profile(user, hash[:profile])
    #   end
    #
    #   Success(user)
    #   end
    #
    #   private
    #
    #   def parse_json(params)
    #   Try(JSON::ParserError) {
    #   JSON.parse(params)
    #   }.to_result
    #   end
    #
    #   def validate(json)
    #   UserSchema.(json).to_monad
    #   end
    #
    #   def create_user(user_data)
    #   Try(Sequel::Error) {
    #   user_repo.create(user_data)
    #   }.to_result
    #   end
    #
    #   def create_profile(user, profile_data)
    #   Try(Sequel::Error) {
    #   user_repo.create_profile(user, profile_data)
    #   }.to_result
    #   end
    #   end
    # @param methods [Array<Symbol>]
    # @return [Module]
    #
    # source://dry-monads//lib/dry/monads/do.rb#105
    def for(*methods); end

    # @api private
    # @raise [Halt.new(result)]
    #
    # source://dry-monads//lib/dry/monads/do.rb#165
    def halt(result); end

    # @api private
    # @private
    #
    # source://dry-monads//lib/dry/monads/do.rb#116
    def included(base); end

    # @api private
    #
    # source://dry-monads//lib/dry/monads/do.rb#138
    def method_visibility(mod, method); end

    # @api private
    #
    # source://dry-monads//lib/dry/monads/do.rb#125
    def wrap_method(target, method, visibility); end
  end
end

# Do::All automatically wraps methods defined in a class with an unwrapping block.
# Similar to what `Do.for(...)` does except wraps every method so you don't have
# to list them explicitly.
#
# @example annotated example
#
#   require 'dry/monads/do/all'
#   require 'dry/monads/result'
#
#   class CreateUser
#   include Dry::Monads::Do::All
#   include Dry::Monads::Result::Mixin
#
#   def call(params)
#   # Unwrap a monadic value using an implicitly passed block
#   # if `validates` returns Failure, the execution will be halted
#   values = yield validate(params)
#   user = create_user(values)
#   # If another block is passed to a method then takes
#   # precedence over the unwrapping block
#   safely_subscribe(values[:email]) { Logger.info("Already subscribed") }
#
#   Success(user)
#   end
#
#   def validate(params)
#   if params.key?(:email)
#   Success(email: params[:email])
#   else
#   Failure(:no_email)
#   end
#   end
#
#   def create_user(user)
#   # Here a block is passed to the method but we don't use it
#   UserRepo.new.add(user)
#   end
#
#   def safely_subscribe(email)
#   repo = SubscriptionRepo.new
#
#   if repo.subscribed?(email)
#   # This calls the logger because a block
#   # explicitly passed from `call`
#   yield
#   else
#   repo.subscribe(email)
#   end
#   end
#   end
#
# source://dry-monads//lib/dry/monads/do/all.rb#57
module Dry::Monads::Do::All
  extend ::Dry::Monads::Do::All::InstanceMixin

  class << self
    # @api private
    # @private
    #
    # source://dry-monads//lib/dry/monads/do/all.rb#102
    def included(base); end

    # @api private
    #
    # source://dry-monads//lib/dry/monads/do/all.rb#113
    def wrap_defined_methods(klass, target); end
  end
end

# @api private
#
# source://dry-monads//lib/dry/monads/do/all.rb#129
module Dry::Monads::Do::All::InstanceMixin
  # @api private
  #
  # source://dry-monads//lib/dry/monads/do/all.rb#131
  def extended(object); end
end

# @private
#
# source://dry-monads//lib/dry/monads/do/all.rb#59
class Dry::Monads::Do::All::MethodTracker < ::Module
  # @return [MethodTracker] a new instance of MethodTracker
  #
  # source://dry-monads//lib/dry/monads/do/all.rb#62
  def initialize(wrappers); end

  # source://dry-monads//lib/dry/monads/do/all.rb#89
  def extend_object(target); end

  # source://dry-monads//lib/dry/monads/do/all.rb#94
  def wrap_method(target, method); end

  # Returns the value of attribute wrappers.
  #
  # source://dry-monads//lib/dry/monads/do/all.rb#60
  def wrappers; end
end

# @api private
#
# source://dry-monads//lib/dry/monads/do.rb#18
class Dry::Monads::Do::Halt < ::StandardError
  # @api private
  # @return [Halt] a new instance of Halt
  #
  # source://dry-monads//lib/dry/monads/do.rb#22
  def initialize(result); end

  # @api private
  #
  # source://dry-monads//lib/dry/monads/do.rb#20
  def result; end
end

# @api private
#
# source://dry-monads//lib/dry/monads/do.rb#30
class Dry::Monads::Do::MethodTracker < ::Module
  # @api private
  # @return [MethodTracker] a new instance of MethodTracker
  #
  # source://dry-monads//lib/dry/monads/do.rb#32
  def initialize(tracked_methods, base, wrapper); end
end

# Do notation as a mixin.
# You can use it in any place in your code, see examples.
#
# @api public
# @example class-level mixin
#
#   class CreateUser
#   extend Dry::Monads::Do::Mixin
#   extend Dry::Monads[:result]
#
#   def self.run(params)
#   self.call do
#   values = bind Validator.validate(params)
#   user = bind UserRepository.create(values)
#
#   Success(user)
#   end
#   end
#   end
# @example using methods defined on Do
#
#   create_user = proc do |params|
#   Do.() do
#   values = bind validate(params)
#   user = bind user_repo.create(values)
#
#   Success(user)
#   end
#   end
#
# source://dry-monads//lib/dry/monads/do/mixin.rb#37
module Dry::Monads::Do::Mixin
  # @api public
  #
  # source://dry-monads//lib/dry/monads/do/mixin.rb#46
  def bind(monads); end

  # @api public
  #
  # source://dry-monads//lib/dry/monads/do/mixin.rb#39
  def call; end
end

# source://dry-monads//lib/dry/monads/do.rb#11
Dry::Monads::Do::VISIBILITY_WORD = T.let(T.unsafe(nil), Hash)

# @api private
# @see Result::Failure
#
# source://dry-monads//lib/dry/monads/result.rb#362
Dry::Monads::Failure = Dry::Monads::Result::Failure

# @api private
# @see Validated::Invalid
#
# source://dry-monads//lib/dry/monads/validated.rb#285
Dry::Monads::Invalid = Dry::Monads::Validated::Invalid

# An error thrown on returning a Failure of unknown type.
#
# source://dry-monads//lib/dry/monads/errors.rb#16
class Dry::Monads::InvalidFailureTypeError < ::StandardError
  # @return [InvalidFailureTypeError] a new instance of InvalidFailureTypeError
  #
  # source://dry-monads//lib/dry/monads/errors.rb#17
  def initialize(failure); end
end

# Lazy is a twin of Task which is always executed on the current thread.
# The underlying mechanism provided by concurrent-ruby ensures the given
# computation is evaluated not more than once (compare with the built-in
# lazy assignement ||= which does not guarantee this).
#
# source://dry-monads//lib/dry/monads/lazy.rb#11
class Dry::Monads::Lazy < ::Dry::Monads::Task
  # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
  def complete?(*args, &block); end

  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#45
  def evaluated?; end

  # Forces the computation. Note that if the computation
  # thrown an error it won't be re-raised as opposed to value!/force!.
  #
  # @return [Lazy]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#39
  def force; end

  # Forces the compution and returns its value.
  #
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#30
  def force!; end

  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#53
  def inspect; end

  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#53
  def to_s; end

  # Forces the compution and returns its value.
  #
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#30
  def value!; end

  class << self
    # @private
    #
    # source://dry-monads//lib/dry/monads/lazy.rb#16
    def new(promise = T.unsafe(nil), &block); end

    private

    # source://dry-monads//lib/dry/monads/task.rb#53
    def [](executor, &block); end
  end
end

# Lazy constructors
#
# source://dry-monads//lib/dry/monads/lazy.rb#69
module Dry::Monads::Lazy::Mixin
  include ::Dry::Monads::Lazy::Mixin::Constructors
end

# Lazy constructors
#
# source://dry-monads//lib/dry/monads/lazy.rb#77
module Dry::Monads::Lazy::Mixin::Constructors
  # Lazy computation contructor
  #
  # @param block [Proc]
  # @return [Lazy]
  #
  # source://dry-monads//lib/dry/monads/lazy.rb#82
  def Lazy(&block); end
end

# @see Dry::Monads::Lazy
#
# source://dry-monads//lib/dry/monads/lazy.rb#71
Dry::Monads::Lazy::Mixin::Lazy = Dry::Monads::Lazy

# @see Dry::Monads::Unit
#
# source://dry-monads//lib/dry/monads/lazy.rb#74
Dry::Monads::Lazy::Mixin::Unit = T.let(T.unsafe(nil), Object)

# The List monad.
#
# source://dry-monads//lib/dry/monads/list.rb#6
class Dry::Monads::List
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Monads::Transformer
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [List] a new instance of List
  #
  # source://dry-monads//lib/dry/monads/list.rb#85
  def initialize(value, type = T.unsafe(nil)); end

  # Concatenates two lists.
  #
  # @example
  #   Dry::Monads::List[1, 2] + Dry::Monads::List[3, 4] # => List[1, 2, 3, 4]
  # @param other [List] Other list
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#147
  def +(other); end

  # Applies the stored functions to the elements of the given list.
  #
  # @param list [List]
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#308
  def apply(list = T.unsafe(nil), &block); end

  # Lifts a block/proc and runs it against each member of the list.
  # The block must return a value coercible to a list.
  # As in other monads if no block given the first argument will
  # be treated as callable and used instead.
  #
  # @example
  #   Dry::Monads::List[1, 2].bind { |x| [x + 1] } # => List[2, 3]
  #   Dry::Monads::List[1, 2].bind(-> x { [x, x + 1] }) # => List[1, 2, 2, 3]
  # @param args [Array<Object>] arguments will be passed to the block or proc
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#101
  def bind(*args); end

  # Iterates over the list and collects Some values.
  #
  # @example with block syntax
  #   n = 20
  #   List[10, 5, 0].collect do |divisor|
  #   if divisor.zero?
  #   None()
  #   else
  #   Some(n / divisor)
  #   end
  #   end
  #   # => List[2, 4]
  # @example without block
  #   List[Some(5), None(), Some(3)].collect.map { |x| x * 2 }
  #   # => [10, 6]
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#345
  def collect; end

  # Pattern matching
  #
  # @api private
  # @example
  #   case List[1, 2, 3]
  #   in List[1, 2, x] then ...
  #   in List[Integer, _, _] then ...
  #   in List[0..2, _, _] then ...
  #   end
  #
  # source://dry-monads//lib/dry/monads/list.rb#370
  def deconstruct; end

  # Whether the list is empty.
  #
  # @return [TrueClass, FalseClass]
  #
  # source://dry-monads//lib/dry/monads/list.rb#203
  def empty?; end

  # Filters elements with a block
  #
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#217
  def filter(&block); end

  # Returns the first element.
  #
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#170
  def first; end

  # Maps a block over the list. Acts as `Array#map`.
  # As in other monads if no block given the first argument will
  # be treated as callable and used instead.
  #
  # @example
  #   Dry::Monads::List[1, 2].fmap { |x| x + 1 } # => List[2, 3]
  # @param args [Array<Object>] arguments will be passed to the block or proc
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#119
  def fmap(*args); end

  # Folds the list from the left.
  #
  # @param initial [Object] Initial value
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#185
  def fold_left(initial, &block); end

  # Folds the list from the right.
  #
  # @param initial [Object] Initial value
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#195
  def fold_right(initial); end

  # Folds the list from the left.
  #
  # @param initial [Object] Initial value
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#185
  def foldl(initial, &block); end

  # Folds the list from the right.
  #
  # @param initial [Object] Initial value
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#195
  def foldr(initial); end

  # Returns the first element wrapped with a `Maybe`.
  #
  # @return [Maybe<Object>]
  #
  # source://dry-monads//lib/dry/monads/list.rb#239
  def head; end

  # Returns a string representation of the list.
  #
  # @example
  #   Dry::Monads::List[1, 2, 3].inspect # => "List[1, 2, 3]"
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/list.rb#157
  def inspect; end

  # Returns the last element.
  #
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#177
  def last; end

  # Maps a block over the list. Acts as `Array#map`.
  # If called without a block, this method returns an enumerator, not a List
  #
  # @return [List, Enumerator]
  #
  # source://dry-monads//lib/dry/monads/list.rb#132
  def map(&block); end

  # Returns the List monad.
  #
  # @return [Monad]
  #
  # source://dry-monads//lib/dry/monads/list.rb#316
  def monad; end

  # Folds the list from the left.
  #
  # @param initial [Object] Initial value
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/list.rb#185
  def reduce(initial, &block); end

  # Reverses the list.
  #
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#232
  def reverse; end

  # Filters elements with a block
  #
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#217
  def select(&block); end

  # List size.
  #
  # @return [Integer]
  #
  # source://dry-monads//lib/dry/monads/list.rb#225
  def size; end

  # Sorts the list.
  #
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#210
  def sort; end

  # Returns list's tail.
  #
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#246
  def tail; end

  # Internal array value
  # Coerces to an array
  #
  # source://dry-monads//lib/dry/monads/list.rb#82
  def to_a; end

  # Internal array value
  # Coerces to an array
  #
  # source://dry-monads//lib/dry/monads/list.rb#82
  def to_ary; end

  # Returns self.
  #
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#323
  def to_monad; end

  # Returns a string representation of the list.
  #
  # @example
  #   Dry::Monads::List[1, 2, 3].inspect # => "List[1, 2, 3]"
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/list.rb#157
  def to_s; end

  # Traverses the list with a block (or without it).
  # This methods "flips" List structure with the given monad (obtained from the type).
  # Note that traversing requires the list to be typed.
  # Also if a block given, its returning type must be equal list's type.
  #
  # @example
  #   List<Result>[Success(1), Success(2)].traverse # => Success([1, 2])
  #   List<Maybe>[Some(1), None, Some(3)].traverse # => None
  # @return [Monad] Result is a monadic value
  #
  # source://dry-monads//lib/dry/monads/list.rb#289
  def traverse(proc = T.unsafe(nil), &block); end

  # Internal array value
  #
  # source://dry-monads//lib/dry/monads/list.rb#82
  def type; end

  # Turns the list into a typed one.
  # Type is required for some operations like .traverse.
  #
  # @param type [Monad] Monad instance
  # @return [List] Typed list
  #
  # source://dry-monads//lib/dry/monads/list.rb#255
  def typed(type = T.unsafe(nil)); end

  # Whether the list is types
  #
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/list.rb#275
  def typed?; end

  # Internal array value
  #
  # source://dry-monads//lib/dry/monads/list.rb#82
  def value; end

  private

  # source://dry-monads//lib/dry/monads/list.rb#376
  def coerce(other); end

  class << self
    # Builds a list.
    #
    # @param values [Array<Object>] List elements
    # @return [List]
    #
    # source://dry-monads//lib/dry/monads/list.rb#12
    def [](*values); end

    # Coerces a value to a list. `nil` will be coerced to an empty list.
    #
    # @param value [Object] Value
    # @param type [Monad] Embedded monad type (used in case of list of monadic values)
    # @return [List]
    #
    # source://dry-monads//lib/dry/monads/list.rb#21
    def coerce(value, type = T.unsafe(nil)); end

    # Wraps a value with a list.
    #
    # @param value [Object] any object
    # @return [List]
    #
    # source://dry-monads//lib/dry/monads/list.rb#41
    def pure(value = T.unsafe(nil), type = T.unsafe(nil), &block); end

    # Iteratively builds a new list from a block returning Maybe values
    #
    # @param state [Object.new] Initial state
    # @param type [#pure] Type of list element
    # @return [List]
    # @see https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#g:9
    #
    # source://dry-monads//lib/dry/monads/list.rb#58
    def unfold(state, type = T.unsafe(nil)); end
  end
end

# Empty list
#
# source://dry-monads//lib/dry/monads/list.rb#381
Dry::Monads::List::EMPTY = T.let(T.unsafe(nil), Dry::Monads::List)

# @private
#
# source://dry-monads//lib/dry/monads/list.rb#384
class Dry::Monads::List::ListBuilder
  # @return [ListBuilder] a new instance of ListBuilder
  #
  # source://dry-monads//lib/dry/monads/list.rb#391
  def initialize(type); end

  # source://dry-monads//lib/dry/monads/list.rb#395
  def [](*args); end

  # source://dry-monads//lib/dry/monads/list.rb#399
  def coerce(value); end

  # source://dry-monads//lib/dry/monads/list.rb#403
  def pure(val = T.unsafe(nil), &block); end

  # Returns the value of attribute type.
  #
  # source://dry-monads//lib/dry/monads/list.rb#389
  def type; end

  class << self
    def [](*_arg0); end
  end
end

# List of maybes
#
# source://dry-monads//lib/dry/monads/list.rb#416
Dry::Monads::List::Maybe = T.let(T.unsafe(nil), Dry::Monads::List::ListBuilder)

# List contructors.
#
# @api public
#
# source://dry-monads//lib/dry/monads/list.rb#427
module Dry::Monads::List::Mixin
  # List constructor.
  #
  # @api public
  # @return [List]
  #
  # source://dry-monads//lib/dry/monads/list.rb#436
  def List(value); end
end

# @api public
# @see Dry::Monads::List
#
# source://dry-monads//lib/dry/monads/list.rb#432
Dry::Monads::List::Mixin::L = Dry::Monads::List

# @api public
# @see Dry::Monads::List
#
# source://dry-monads//lib/dry/monads/list.rb#429
Dry::Monads::List::Mixin::List = Dry::Monads::List

# List of results
#
# source://dry-monads//lib/dry/monads/list.rb#413
Dry::Monads::List::Result = T.let(T.unsafe(nil), Dry::Monads::List::ListBuilder)

# List of tasks
#
# source://dry-monads//lib/dry/monads/list.rb#410
Dry::Monads::List::Task = T.let(T.unsafe(nil), Dry::Monads::List::ListBuilder)

# List of tries
#
# source://dry-monads//lib/dry/monads/list.rb#419
Dry::Monads::List::Try = T.let(T.unsafe(nil), Dry::Monads::List::ListBuilder)

# List of validation results
#
# source://dry-monads//lib/dry/monads/list.rb#422
Dry::Monads::List::Validated = T.let(T.unsafe(nil), Dry::Monads::List::ListBuilder)

# Represents a value which can exist or not, i.e. it could be nil.
#
# @api public
#
# source://dry-monads//lib/dry/monads/maybe.rb#8
class Dry::Monads::Maybe
  include ::Dry::Monads::Transformer
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # Returns true for an instance of a {Maybe::None} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#49
  def failure?; end

  # Returns the Maybe monad.
  # This is how we're doing polymorphism in Ruby 😕
  #
  # @api public
  # @return [Monad]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#78
  def monad; end

  # Returns true for an instance of a {Maybe::None} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#49
  def none?; end

  # Returns true for an instance of a {Maybe::Some} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#55
  def some?; end

  # Returns true for an instance of a {Maybe::Some} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#55
  def success?; end

  # Returns self, added to keep the interface compatible with that of Either monad types.
  #
  # @api public
  # @return [Maybe::Some, Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#63
  def to_maybe; end

  # Returns self.
  #
  # @api public
  # @return [Maybe::Some, Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#70
  def to_monad; end

  class << self
    # Wraps the given value with into a Maybe object.
    #
    # @api public
    # @param value [Object] value to be stored in the monad
    # @return [Maybe::Some, Maybe::None]
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#22
    def coerce(value); end

    # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
    def lift(*args, &block); end

    # Wraps the given value with `Some`.
    #
    # @api public
    # @param value [Object] value to be wrapped with Some
    # @param block [Object] block to be wrapped with Some
    # @return [Maybe::Some]
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#36
    def pure(value = T.unsafe(nil), &block); end

    # Reutrns a Some wrapper converted to a block
    #
    # @api public
    # @return [Proc]
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#43
    def to_proc; end
  end
end

# Utilities for working with hashes storing Maybe values
#
# @api public
#
# source://dry-monads//lib/dry/monads/maybe.rb#334
module Dry::Monads::Maybe::Hash
  class << self
    # Traverses a hash with maybe values. If any value is None then None is returned
    #
    # @api public
    # @example
    #   Maybe::Hash.all(foo: Some(1), bar: Some(2)) # => Some(foo: 1, bar: 2)
    #   Maybe::Hash.all(foo: Some(1), bar: None())  # => None()
    #   Maybe::Hash.all(foo: None(), bar: Some(2))  # => None()
    # @param hash [::Hash<Object,Maybe>]
    # @return [Maybe<::Hash>]
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#345
    def all(hash, trace = T.unsafe(nil)); end

    # Traverses a hash with maybe values. Some values are unwrapped, keys with
    # None values are removed
    #
    # @api public
    # @example
    #   Maybe::Hash.filter(foo: Some(1), bar: Some(2)) # => { foo: 1, bar: 2 }
    #   Maybe::Hash.filter(foo: Some(1), bar: None())  # => { foo: 1 }
    #   Maybe::Hash.filter(foo: None(), bar: Some(2))  # => { bar: 2 }
    # @param hash [::Hash<Object,Maybe>]
    # @return [::Hash]
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#368
    def filter(hash); end
  end
end

# A module that can be included for easier access to Maybe monads.
#
# @api public
#
# source://dry-monads//lib/dry/monads/maybe.rb#293
module Dry::Monads::Maybe::Mixin
  include ::Dry::Monads::Maybe::Mixin::Constructors
end

# @api public
# @private
#
# source://dry-monads//lib/dry/monads/maybe.rb#302
module Dry::Monads::Maybe::Mixin::Constructors
  # @api public
  # @param value [Object] the value to be stored in the monad
  # @return [Maybe::Some, Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#305
  def Maybe(value); end

  # @api public
  # @return [Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#325
  def None; end

  # Some constructor
  #
  # @api public
  # @overload Some
  # @overload Some
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#319
  def Some(value = T.unsafe(nil), &block); end
end

# @api public
# @see Dry::Monads::Maybe
#
# source://dry-monads//lib/dry/monads/maybe.rb#295
Dry::Monads::Maybe::Mixin::Maybe = Dry::Monads::Maybe

# @api public
# @see Maybe::None
#
# source://dry-monads//lib/dry/monads/maybe.rb#299
Dry::Monads::Maybe::Mixin::None = Dry::Monads::Maybe::None

# @api public
# @see Maybe::Some
#
# source://dry-monads//lib/dry/monads/maybe.rb#297
Dry::Monads::Maybe::Mixin::Some = Dry::Monads::Maybe::Some

# Represents an absence of a value, i.e. the value nil.
#
# @api public
#
# source://dry-monads//lib/dry/monads/maybe.rb#191
class Dry::Monads::Maybe::None < ::Dry::Monads::Maybe
  include ::Dry::Monads::RightBiased::Left

  # @api public
  # @return [None] a new instance of None
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#212
  def initialize(trace = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#260
  def ==(other); end

  # Pattern matching
  #
  # @api private
  # @example
  #   case Some(:foo)
  #   in Some(Integer) then ...
  #   in Some(:bar) then ...
  #   in None() then ...
  #   end
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#280
  def deconstruct; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#260
  def eql?(other); end

  # @api public
  # @return [Maybe::None]
  # @see Maybe::Some#filter
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#287
  def filter(_ = T.unsafe(nil)); end

  # @api public
  # @private
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#266
  def hash; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#254
  def inspect; end

  # @api public
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#284
  def maybe(*_arg0); end

  # If a block is given passes internal value to it and returns the result,
  # otherwise simply returns the parameter val.
  #
  # @api public
  # @example
  #   Dry::Monads.None.or('no value') # => "no value"
  #   Dry::Monads.None.or { Time.now } # => current time
  # @param args [Array<Object>] if no block given the first argument will be returned
  #   otherwise arguments will be transparently passed to the block
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#231
  def or(*args); end

  # A lifted version of `#or`. Applies `Maybe.coerce` to the passed value or
  # to the block result.
  #
  # @api public
  # @example
  #   Dry::Monads.None.or_fmap('no value') # => Some("no value")
  #   Dry::Monads.None.or_fmap { Time.now } # => Some(current time)
  # @param args [Array<Object>] arguments will be passed to the underlying `#or` call
  # @return [Maybe::Some, Maybe::None] Lifted `#or` result, i.e. nil will be mapped to None,
  #   other values will be wrapped with Some
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#249
  def or_fmap(*_arg0, **_arg1, &_arg2); end

  # Converts to Failure(fallback_value)
  #
  # @api public
  # @param fail [#call] Fallback value
  # @param block [Proc] Fallback block
  # @return [Failure<Any>]
  #
  # source://dry-monads//lib/dry/monads/result.rb#419
  def to_result(fail = T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#254
  def to_s; end

  # Line where the value was constructed
  #
  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#210
  def trace; end

  class << self
    # source://dry-monads//lib/dry/monads/maybe.rb#195
    def instance; end

    private

    # @api private
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#198
    def method_missing(m, *_arg1); end
  end
end

# Represents a value that is present, i.e. not nil.
#
# @api public
#
# source://dry-monads//lib/dry/monads/maybe.rb#85
class Dry::Monads::Maybe::Some < ::Dry::Monads::Maybe
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Monads::RightBiased::Right

  # @api public
  # @raise [ArgumentError]
  # @return [Some] a new instance of Some
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#103
  def initialize(value = T.unsafe(nil)); end

  # Accepts a block and runs it against the wrapped value.
  # If the block returns a trurhy value the result is self,
  # otherwise None. If no block is given, the value serves
  # and its result.
  #
  # @api public
  # @param with [#call] positional block
  # @param block [Proc] block
  # @return [Maybe::None, Maybe::Some]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#167
  def filter(with = T.unsafe(nil), &block); end

  # Does the same thing as #bind except it also wraps the value
  # in an instance of Maybe::Some monad. This allows for easier
  # chaining of calls.
  #
  # @api public
  # @example
  #   Dry::Monads.Some(4).fmap(&:succ).fmap(->(n) { n**2 }) # => Some(25)
  # @param args [Array<Object>] arguments will be transparently passed through to #bind
  # @return [Maybe::Some, Maybe::None] Wrapped result, i.e. nil will be mapped to None,
  #   other values will be wrapped with Some
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#121
  def fmap(*_arg0, **_arg1, &_arg2); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#178
  def inspect; end

  # Does the same thing as #bind except it also wraps the value
  # in an instance of the Maybe monad. This allows for easier
  # chaining of calls.
  #
  # @api public
  # @example
  #   Dry::Monads.Some(4).maybe(&:succ).maybe(->(n) { n**2 }) # => Some(25)
  #   Dry::Monads.Some(4).maybe(&:succ).maybe(->(_) { nil }) # => None()
  # @param args [Array<Object>] arguments will be transparently passed through to #bind
  # @return [Maybe::Some, Maybe::None] Wrapped result, i.e. nil will be mapped to None,
  #   other values will be wrapped with Some
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#154
  def maybe(*_arg0, **_arg1, &_arg2); end

  # Converts to Sucess(value!)
  #
  # @api public
  # @param fail [#call] Fallback value
  # @param block [Proc] Fallback block
  # @return [Success<Any>]
  #
  # source://dry-monads//lib/dry/monads/result.rb#408
  def to_result(_fail = T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#178
  def to_s; end

  class << self
    # Shortcut for Some([...])
    #
    #  @example
    #    include Dry::Monads[:maybe]
    #
    #    def call
    #      Some[200, {}, ['ok']] # => Some([200, {}, ['ok']])
    #    end
    #
    # @api public
    #
    # source://dry-monads//lib/dry/monads/maybe.rb#99
    def [](*value); end

    def call(*_arg0); end

    # source://dry-monads//lib/dry/monads/right_biased.rb#15
    def to_proc; end
  end
end

# @see Maybe::None
#
# source://dry-monads//lib/dry/monads/maybe.rb#381
Dry::Monads::None = Dry::Monads::Maybe::None

# Represents an operation which either succeeded or failed.
#
# @api public
#
# source://dry-monads//lib/dry/monads/result.rb#8
class Dry::Monads::Result
  include ::Dry::Monads::Transformer

  # @api public
  # @return [Object] Error
  #
  # source://dry-monads//lib/dry/monads/result.rb#16
  def failure; end

  # Returns the Result monad.
  # This is how we're doing polymorphism in Ruby 😕
  #
  # @api public
  # @return [Monad]
  #
  # source://dry-monads//lib/dry/monads/result.rb#52
  def monad; end

  # @api public
  # @return [Object] Successful result
  #
  # source://dry-monads//lib/dry/monads/result.rb#13
  def success; end

  # Returns self.
  #
  # @api public
  # @return [Result::Success, Result::Failure]
  #
  # source://dry-monads//lib/dry/monads/result.rb#44
  def to_monad; end

  # Returns self, added to keep the interface compatible with other monads.
  #
  # @api public
  # @return [Result::Success, Result::Failure]
  #
  # source://dry-monads//lib/dry/monads/result.rb#37
  def to_result; end

  class << self
    # Wraps the given value with Success.
    #
    # @api public
    # @overload pure
    # @overload pure
    #
    # source://dry-monads//lib/dry/monads/result.rb#29
    def pure(value = T.unsafe(nil), &block); end
  end
end

# Represents a value of a failed operation.
#
# @api public
#
# source://dry-monads//lib/dry/monads/result.rb#155
class Dry::Monads::Result::Failure < ::Dry::Monads::Result
  include ::Dry::Monads::RightBiased::Left
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param value [Object] failure value
  # @param trace [String] caller line
  # @return [Failure] a new instance of Failure
  #
  # source://dry-monads//lib/dry/monads/result.rb#190
  def initialize(value, trace = T.unsafe(nil)); end

  # @api public
  # @param other [Result]
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/result.rb#278
  def ===(other); end

  # Lifts a block/proc over Failure
  #
  # @api public
  # @overload alt_map
  # @overload alt_map
  #
  # source://dry-monads//lib/dry/monads/result.rb#304
  def alt_map(proc = T.unsafe(nil), &block); end

  # Returns result of applying second function to the internal value.
  #
  # @api public
  # @example
  #   Dry::Monads.Failure(1).either(-> x { x + 1 }, -> x { x + 2 }) # => 3
  # @param _ [#call] Ignored
  # @param g [#call] Function to call
  # @return [Any] Return value of `g`
  #
  # source://dry-monads//lib/dry/monads/result.rb#290
  def either(_, g); end

  # @api public
  # @private
  #
  # source://dry-monads//lib/dry/monads/result.rb#197
  def failure; end

  # Returns true
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/result.rb#209
  def failure?; end

  # Transform to a Success instance
  #
  # @api public
  # @return [Result::Success]
  #
  # source://dry-monads//lib/dry/monads/result.rb#263
  def flip; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/result.rb#251
  def inspect; end

  # If a block is given passes internal value to it and returns the result,
  # otherwise simply returns the first argument.
  #
  # @api public
  # @example
  #   Dry::Monads.Failure(ArgumentError.new('error message')).or(&:message)
  #   # => "error message"
  # @param args [Array<Object>] arguments that will be passed to a block
  #   if one was given, otherwise the first
  #   value will be returned
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/result.rb#229
  def or(*args); end

  # A lifted version of `#or`. Wraps the passed value or the block
  # result with Result::Success.
  #
  # @api public
  # @example
  #   Dry::Monads.Failure.new('no value').or_fmap('value') # => Success("value")
  #   Dry::Monads.Failure.new('no value').or_fmap { 'value' } # => Success("value")
  # @param args [Array<Object>] arguments will be passed to the underlying `#or` call
  # @return [Result::Success] Wrapped value
  #
  # source://dry-monads//lib/dry/monads/result.rb#246
  def or_fmap(*_arg0, **_arg1, &_arg2); end

  # Apply the first function to value.
  #
  # @api public
  #
  # source://dry-monads//lib/dry/monads/result.rb#204
  def result(f, _); end

  # Returns false
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/result.rb#214
  def success?; end

  # @return [Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#396
  def to_maybe; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/result.rb#251
  def to_s; end

  # Transforms to Validated
  #
  # @api public
  # @return [Validated::Invalid]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#301
  def to_validated; end

  # Line where the value was constructed
  #
  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/result.rb#186
  def trace; end

  # @api public
  # @see RightBiased::Left#value_or
  #
  # source://dry-monads//lib/dry/monads/result.rb#268
  def value_or(val = T.unsafe(nil)); end

  class << self
    # Shortcut for Failure([...])
    #
    #  @example
    #    include Dry::Monads[:result]
    #
    #    def call
    #      Failure[:error, :not_found] # => Failure([:error, :not_found])
    #    end
    #
    # @api public
    #
    # source://dry-monads//lib/dry/monads/result.rb#171
    def [](*value); end

    def call(*_arg0); end

    # Returns a constructor proc
    #
    # @api public
    # @return [Proc]
    #
    # source://dry-monads//lib/dry/monads/result.rb#178
    def to_proc; end
  end
end

# @api private
# @private
# @see Monads#Result
#
# source://dry-monads//lib/dry/monads/result/fixed.rb#10
class Dry::Monads::Result::Fixed < ::Module
  # @api private
  # @return [Fixed] a new instance of Fixed
  #
  # source://dry-monads//lib/dry/monads/result/fixed.rb#15
  def initialize(error, **_options); end

  private

  # @api private
  #
  # source://dry-monads//lib/dry/monads/result/fixed.rb#37
  def included(base); end

  class << self
    # @api private
    #
    # source://dry-monads//lib/dry/monads/result/fixed.rb#11
    def [](error, **options); end
  end
end

# A module that can be included for easier access to Result monads.
#
# @api public
#
# source://dry-monads//lib/dry/monads/result.rb#313
module Dry::Monads::Result::Mixin
  include ::Dry::Monads::Result::Mixin::Constructors
end

# Value constructors
#
# @api public
#
# source://dry-monads//lib/dry/monads/result.rb#321
module Dry::Monads::Result::Mixin::Constructors
  # Failure constructor
  #
  # @api public
  # @overload Success
  # @overload Success
  #
  # source://dry-monads//lib/dry/monads/result.rb#347
  def Failure(value = T.unsafe(nil), &block); end

  # Success constructor
  #
  # @api public
  # @overload Success
  # @overload Success
  #
  # source://dry-monads//lib/dry/monads/result.rb#332
  def Success(value = T.unsafe(nil), &block); end
end

# @api public
# @see Result::Failure
#
# source://dry-monads//lib/dry/monads/result.rb#317
Dry::Monads::Result::Mixin::Failure = Dry::Monads::Result::Failure

# @api public
# @see Result::Success
#
# source://dry-monads//lib/dry/monads/result.rb#315
Dry::Monads::Result::Mixin::Success = Dry::Monads::Result::Success

# Represents a value of a successful operation.
#
# @api public
#
# source://dry-monads//lib/dry/monads/result.rb#59
class Dry::Monads::Result::Success < ::Dry::Monads::Result
  include ::Dry::Monads::RightBiased::Right
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Deprecations::Interface

  # @api public
  # @param value [Object] a value of a successful operation
  # @return [Success] a new instance of Success
  #
  # source://dry-monads//lib/dry/monads/result.rb#80
  def initialize(value); end

  # Ignores values and returns self, see {Failure#alt_map}
  #
  # @api public
  # @return [Result::Success]
  #
  # source://dry-monads//lib/dry/monads/result.rb#147
  def alt_map(_ = T.unsafe(nil)); end

  # Returns result of applying first function to the internal value.
  #
  # @api public
  # @example
  #   Dry::Monads.Success(1).either(-> x { x + 1 }, -> x { x + 2 }) # => 2
  # @param f [#call] Function to apply
  # @param _ [#call] Ignored
  # @return [Any] Return value of `f`
  #
  # source://dry-monads//lib/dry/monads/result.rb#123
  def either(f, _); end

  # Returns false
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/result.rb#93
  def failure?; end

  # Transforms to a Failure instance
  #
  # @api public
  # @return [Result::Failure]
  #
  # source://dry-monads//lib/dry/monads/result.rb#140
  def flip; end

  # Does the same thing as #bind except it also wraps the value
  # in an instance of Result::Success monad. This allows for easier
  # chaining of calls.
  #
  # @api public
  # @example
  #   Dry::Monads.Success(4).fmap(&:succ).fmap(->(n) { n**2 }) # => Success(25)
  # @param args [Array<Object>] arguments will be transparently passed through to #bind
  # @return [Result::Success]
  #
  # source://dry-monads//lib/dry/monads/result.rb#111
  def fmap(*_arg0, **_arg1, &_arg2); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/result.rb#128
  def inspect; end

  # Apply the second function to value.
  #
  # @api public
  #
  # source://dry-monads//lib/dry/monads/result.rb#88
  def result(_, f); end

  # @api public
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#24
  def success; end

  # Returns true
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/result.rb#98
  def success?; end

  # @return [Maybe]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#388
  def to_maybe; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/result.rb#128
  def to_s; end

  # Transforms to Validated
  #
  # @api public
  # @return [Validated::Valid]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#292
  def to_validated; end

  class << self
    # Shortcut for Success([...])
    #
    #  @example
    #    include Dry::Monads[:result]
    #
    #    def call
    #      Success[200, {}, ['ok']] # => Success([200, {}, ['ok']])
    #    end
    #
    # @api public
    #
    # source://dry-monads//lib/dry/monads/result.rb#73
    def [](*value); end

    def call(*_arg0); end

    # source://dry-monads//lib/dry/monads/right_biased.rb#15
    def to_proc; end
  end
end

# A common module for right-biased monads, such as Result/Either, Maybe, and Try.
#
# @api private
#
# source://dry-monads//lib/dry/monads/right_biased.rb#6
module Dry::Monads::RightBiased; end

# Left/wrong/erroneous part
#
# @api public
#
# source://dry-monads//lib/dry/monads/right_biased.rb#252
module Dry::Monads::RightBiased::Left
  # Returns self back. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#359
  def and(_); end

  # Ignores the input parameter and returns self. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#335
  def apply(*_arg0); end

  # Ignores the input parameter and returns self. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#268
  def bind(*_arg0); end

  # Pattern matching
  #
  # @api private
  # @example
  #   case Success(x)
  #   in Success(Integer) then ...
  #   in Success(2..100) then ...
  #   in Success(2..200 => code) then ...
  #   in Failure(_) then ...
  #   end
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#374
  def deconstruct; end

  # Pattern matching hash values
  #
  # @api private
  # @example
  #   case Failure(x)
  #   in Failure(code: 400...500) then :user_error
  #   in Failure(code: 500...600) then :server_error
  #   end
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#393
  def deconstruct_keys(keys); end

  # Returns self back. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#343
  def discard; end

  # Returns self back. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#351
  def flatten; end

  # Ignores the input parameter and returns self. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#284
  def fmap(*_arg0); end

  # Left-biased #bind version.
  #
  # @api public
  # @example
  #   Dry::Monads.Left(ArgumentError.new('error message')).or(&:message) # => "error message"
  #   Dry::Monads.None.or('no value') # => "no value"
  #   Dry::Monads.None.or { Time.now } # => current time
  # @raise [NotImplementedError]
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#296
  def or(*_arg0); end

  # A lifted version of `#or`. This is basically `#or` + `#fmap`.
  #
  # @api public
  # @example
  #   Dry::Monads.None.or_fmap('no value') # => Some("no value")
  #   Dry::Monads.None.or_fmap { Time.now } # => Some(current time)
  # @raise [NotImplementedError]
  # @return [RightBiased::Left, RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#316
  def or_fmap(*_arg0); end

  # Ignores the input parameter and returns self. It exists to keep the interface
  # identical to that of {RightBiased::Right}.
  #
  # @api public
  # @return [RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#276
  def tee(*_arg0); end

  # Raises an error on accessing internal value
  #
  # @api public
  # @raise [UnwrapError]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#260
  def value!; end

  # Returns the passed value
  #
  # @api public
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#323
  def value_or(val = T.unsafe(nil)); end

  # Returns the passed value. Works in pair with {RightBiased::Right#|}.
  #
  # @api public
  # @param alt [RightBiased::Right, RightBiased::Left]
  # @return [RightBiased::Right, RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#305
  def |(alt); end

  class << self
    # @api public
    # @private
    # @return [String] Caller location
    #
    # source://dry-monads//lib/dry/monads/right_biased.rb#255
    def trace_caller; end
  end
end

# Right part
#
# @api public
#
# source://dry-monads//lib/dry/monads/right_biased.rb#10
module Dry::Monads::RightBiased::Right
  # @api public
  # @param other [Object]
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#136
  def ===(other); end

  # Combines the wrapped value with another monadic value.
  # If both values are right-sided, yields a block and passes a tuple
  # of values there. If no block given, returns a tuple of values wrapped with
  # a monadic structure.
  #
  # @api public
  # @example
  #   include Dry::Monads::Result::Mixin
  #
  #   Success(3).and(Success(5)) # => Success([3, 5])
  #   Success(3).and(Failure(:not_a_number)) # => Failure(:not_a_number)
  #   Failure(:not_a_number).and(Success(5)) # => Failure(:not_a_number)
  #   Success(3).and(Success(5)) { |a, b| a + b } # => Success(8)
  # @param mb [RightBiased::Left, RightBiased::Right]
  # @return [RightBiased::Left, RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#181
  def and(mb); end

  # Applies the stored value to the given argument if the argument has type of Right,
  # otherwise returns the argument.
  #
  # @api public
  # @example happy path
  #   create_user = Dry::Monads::Success(CreateUser.new)
  #   name = Success("John")
  #   create_user.apply(name) # equivalent to CreateUser.new.call("John")
  # @example unhappy path
  #   name = Failure(:name_missing)
  #   create_user.apply(name) # => Failure(:name_missing)
  # @return [RightBiased::Left, RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#126
  def apply(val = T.unsafe(nil), &block); end

  # Calls the passed in Proc object with value stored in self
  # and returns the result.
  #
  # If proc is nil, it expects a block to be given and will yield to it.
  #
  # @api public
  # @example
  #   Dry::Monads.Right(4).bind(&:succ) # => 5
  # @param args [Array<Object>] arguments that will be passed to a block
  #   if one was given, otherwise the first
  #   value assumed to be a Proc (callable)
  #   object and the rest of args will be passed
  #   to this object along with the internal value
  # @return [Object] result of calling proc or block on the internal value
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#42
  def bind(*args, **kwargs); end

  # Pattern matching
  #
  # @api private
  # @example
  #   case Success(x)
  #   in Success(Integer) then ...
  #   in Success(2..100) then ...
  #   in Success(2..200 => code) then ...
  #   end
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#203
  def deconstruct; end

  # Pattern matching hash values
  #
  # @api private
  # @example
  #   case Success(x)
  #   in Success(code: 200...300) then :ok
  #   in Success(code: 300...400) then :redirect
  #   in Success(code: 400...500) then :user_error
  #   in Success(code: 500...600) then :server_error
  #   end
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#224
  def deconstruct_keys(keys); end

  # Maps the value to Dry::Monads::Unit, useful when you don't care
  # about the actual value.
  #
  # @api public
  # @example
  #   Dry::Monads::Success(:success).discard
  #   # => Success(Unit)
  # @return [RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#148
  def discard; end

  # Removes one level of monad structure by joining two values.
  #
  # @api public
  # @example
  #   include Dry::Monads::Result::Mixin
  #   Success(Success(5)).flatten # => Success(5)
  #   Success(Failure(:not_a_number)).flatten # => Failure(:not_a_number)
  #   Failure(:not_a_number).flatten # => Failure(:not_a_number)
  # @return [RightBiased::Right, RightBiased::Left]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#161
  def flatten; end

  # Abstract method for lifting a block over the monad type.
  # Must be implemented for a right-biased monad.
  #
  # @api public
  # @raise [NotImplementedError]
  # @return [RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#76
  def fmap(*_arg0); end

  # Ignores arguments and returns self. It exists to keep the interface
  # identical to that of {RightBiased::Left}.
  #
  # @api public
  # @return [RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#84
  def or(*_arg0); end

  # A lifted version of `#or`. For {RightBiased::Right} acts in the same way as `#or`,
  # that is returns itselt.
  #
  # @api public
  # @return [RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#102
  def or_fmap(*_arg0); end

  # Does the same thing as #bind except it returns the original monad
  # when the result is a Right.
  #
  # @api public
  # @example
  #   Dry::Monads.Right(4).tee { Right('ok') } # => Right(4)
  #   Dry::Monads.Right(4).tee { Left('fail') } # => Left('fail')
  # @param args [Array<Object>] arguments will be transparently passed through to #bind
  # @return [RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#68
  def tee(*_arg0, **_arg1, &_arg2); end

  # Unwraps the underlying value
  #
  # @api public
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#24
  def value!; end

  # Returns value. It exists to keep the interface identical to that of RightBiased::Left
  #
  # @api public
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#109
  def value_or(_val = T.unsafe(nil)); end

  # Ignores arguments and returns self. It exists to keep the interface
  # identical to that of {RightBiased::Left}.
  #
  # @api public
  # @param _alt [RightBiased::Right, RightBiased::Left]
  # @return [RightBiased::Right]
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#94
  def |(_alt); end

  private

  # @api private
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#244
  def curry; end

  # @api private
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#235
  def destructure(value); end

  class << self
    # @api public
    # @private
    # @private
    #
    # source://dry-monads//lib/dry/monads/right_biased.rb#12
    def included(m); end
  end
end

# @see Maybe::Some
#
# source://dry-monads//lib/dry/monads/maybe.rb#379
Dry::Monads::Some = Dry::Monads::Maybe::Some

# @api private
# @see Result::Success
#
# source://dry-monads//lib/dry/monads/result.rb#360
Dry::Monads::Success = Dry::Monads::Result::Success

# The Task monad represents an async computation. The implementation
# is a rather thin wrapper of Concurrent::Promise from the concurrent-ruby.
# The API supports setting a custom executor from concurrent-ruby.
#
# @api public
#
# source://dry-monads//lib/dry/monads/task.rb#12
class Dry::Monads::Task
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Task] a new instance of Task
  #
  # source://dry-monads//lib/dry/monads/task.rb#89
  def initialize(promise); end

  # Compares two tasks. Note, it works
  # good enough only for complete tasks.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/task.rb#199
  def ==(other); end

  # Applies the stored value to the given argument.
  #
  # @api public
  # @example
  #   Task.
  #   pure { |x, y| x ** y }.
  #   apply(Task { 2 }).
  #   apply(Task { 3 }).
  #   to_maybe # => Some(8)
  # @param val [Task]
  # @return [Task]
  #
  # source://dry-monads//lib/dry/monads/task.rb#236
  def apply(val = T.unsafe(nil), &block); end

  # Composes two tasks to run one after another.
  # A more common name is `then` exists as an alias.
  #
  # @api public
  # @param block [Proc] A block that yields the result of the current task
  #   and returns another task
  # @return [Task]
  #
  # source://dry-monads//lib/dry/monads/task.rb#123
  def bind(&block); end

  # Whether the computation is complete.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/task.rb#209
  def complete?; end

  # Maps a successful result to Unit, effectively discards it
  #
  # @api public
  # @return [Task]
  #
  # source://dry-monads//lib/dry/monads/task.rb#244
  def discard; end

  # Lifts a block over the Task monad.
  #
  # @api public
  # @param block [Proc]
  # @return [Task]
  #
  # source://dry-monads//lib/dry/monads/task.rb#113
  def fmap(&block); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/task.rb#129
  def inspect; end

  # @api public
  # @return [Class]
  #
  # source://dry-monads//lib/dry/monads/task.rb#214
  def monad; end

  # Rescues the error with a block that returns another task.
  #
  # @api public
  # @param block [Proc]
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/task.rb#159
  def or(&block); end

  # Tranforms the error if the computation wasn't successful.
  #
  # @api public
  # @param block [Proc]
  # @return [Task]
  #
  # source://dry-monads//lib/dry/monads/task.rb#151
  def or_fmap(&block); end

  # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
  def then(*args, &block); end

  # Converts to Maybe. Blocks the current thread if required.
  #
  # @return [Maybe]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#406
  def to_maybe; end

  # Returns self.
  #
  # @api public
  # @return [Maybe::Some, Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/task.rb#221
  def to_monad; end

  # Converts to Result. Blocks the current thread if required.
  #
  # @api private
  # @return [Result]
  #
  # source://dry-monads//lib/dry/monads/result.rb#433
  def to_result; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/task.rb#129
  def to_s; end

  # Retrieves the value of the computation.
  # Blocks current thread if the underlying promise
  # hasn't been complete yet.
  # Throws an error if the computation failed.
  #
  # @api public
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/task.rb#100
  def value!; end

  # Extracts the resulting value if the computation was successful
  # otherwise yields the block and returns its result.
  #
  # @api public
  # @param block [Proc]
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/task.rb#183
  def value_or(&block); end

  # Blocks the current thread until the task is complete.
  #
  # @api public
  # @return [Task]
  #
  # source://dry-monads//lib/dry/monads/task.rb#190
  def wait(timeout = T.unsafe(nil)); end

  protected

  # @api private
  #
  # source://dry-monads//lib/dry/monads/task.rb#85
  def promise; end

  private

  # @api private
  #
  # source://dry-monads//lib/dry/monads/task.rb#265
  def compare_promises(x, y); end

  # @api private
  #
  # source://dry-monads//lib/dry/monads/task.rb#251
  def curry(value); end

  class << self
    # Creates a Task with the given executor
    #
    # @api public
    # @example providing an executor instance, using Ruby 2.5+ syntax
    #   IO = Concurrent::ThreadPoolExecutor.new
    #   Task[IO] { do_http_request }
    # @example using a predefined executor
    #   Task[:fast] { do_quick_task }
    # @param executor [Concurrent::AbstractExecutorService, Symbol] Either an executor instance
    #   or a name of predefined global
    #   from concurrent-ruby
    # @return [Task]
    #
    # source://dry-monads//lib/dry/monads/task.rb#53
    def [](executor, &block); end

    # Returns a failed task from the given exception
    #
    # @api public
    # @param exc [Exception]
    # @return [Task]
    #
    # source://dry-monads//lib/dry/monads/task.rb#76
    def failed(exc); end

    # Creates a Task from a block
    #
    # @api public
    # @overload new
    # @overload new
    #
    # source://dry-monads//lib/dry/monads/task.rb#30
    def new(promise = T.unsafe(nil), &block); end

    # Returns a completed task from the given value
    #
    # @api public
    # @overload pure
    # @overload pure
    #
    # source://dry-monads//lib/dry/monads/task.rb#67
    def pure(value = T.unsafe(nil), &block); end
  end
end

# Task constructors.
#
# @api public
#
# source://dry-monads//lib/dry/monads/task.rb#274
module Dry::Monads::Task::Mixin
  include ::Dry::Monads::Task::Mixin::Constructors

  class << self
    # Created a mixin with the given executor injected.
    #
    # @api public
    # @param executor [Concurrent::AbstractExecutorService, Symbol]
    # @return [Module]
    #
    # source://dry-monads//lib/dry/monads/task.rb#285
    def [](executor); end
  end
end

# Task constructors
#
# @api public
#
# source://dry-monads//lib/dry/monads/task.rb#300
module Dry::Monads::Task::Mixin::Constructors
  # Builds a new Task instance.
  #
  # @api public
  # @param block [Proc]
  # @return Task
  #
  # source://dry-monads//lib/dry/monads/task.rb#305
  def Task(&block); end
end

# @api public
# @private
#
# source://dry-monads//lib/dry/monads/task.rb#276
Dry::Monads::Task::Mixin::Task = Dry::Monads::Task

# @api public
# @see Dry::Monads::Unit
#
# source://dry-monads//lib/dry/monads/task.rb#279
Dry::Monads::Task::Mixin::Unit = T.let(T.unsafe(nil), Object)

# @api private
#
# source://dry-monads//lib/dry/monads/task.rb#14
class Dry::Monads::Task::Promise < ::Concurrent::Promise
  # source://concurrent-ruby/1.2.2/lib/concurrent-ruby/concurrent/promise.rb#533
  def on_fulfill(result); end

  # source://concurrent-ruby/1.2.2/lib/concurrent-ruby/concurrent/promise.rb#539
  def on_reject(reason); end
end

# Advanced tranformations.
#
# @api private
#
# source://dry-monads//lib/dry/monads/transformer.rb#6
module Dry::Monads::Transformer
  # Lifts a block/proc over the 2-level nested structure.
  # This is essentially fmap . fmap (. is the function composition
  # operator from Haskell) or the functor instance for
  # a two-level monadic structure like List Either.
  #
  # @api private
  # @example
  #   List[Right(1), Left(1)].fmap2 { |x| x + 1 } # => List[Right(2), Left(1)]
  #   Right(None).fmap2 { |x| x + 1 } # => Right(None)
  # @param args [Array<Object>] arguments will be passed to the block or the proc
  # @return [Object] some monadic value
  #
  # source://dry-monads//lib/dry/monads/transformer.rb#18
  def fmap2(*args); end

  # Lifts a block/proc over the 3-level nested structure.
  #
  # @api private
  # @example
  #   List[Right(Some(1)), Left(Some(1))].fmap3 { |x| x + 1 }
  #   # => List[Right(Some(2)), Left(Some(1))]
  #   Right(None).fmap3 { |x| x + 1 } # => Right(None)
  # @param args [Array<Object>] arguments will be passed to the block or the proc
  # @return [Object] some monadic value
  #
  # source://dry-monads//lib/dry/monads/transformer.rb#36
  def fmap3(*args); end
end

# List of default traverse functions for types.
# It is implicitly used by List#traverse for
# making common cases easier to handle.
#
# @api private
#
# source://dry-monads//lib/dry/monads/traverse.rb#15
Dry::Monads::Traverse = T.let(T.unsafe(nil), Hash)

# Represents a value which can be either success or a failure (an exception).
# Use it to wrap code that can raise exceptions.
#
# @api public
#
# source://dry-monads//lib/dry/monads/try.rb#9
class Dry::Monads::Try
  # Returns true for an instance of a {Try::Error} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/try.rb#82
  def error?; end

  # @api public
  # @return [Exception] Caught exception
  #
  # source://dry-monads//lib/dry/monads/try.rb#16
  def exception; end

  # Returns true for an instance of a {Try::Error} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/try.rb#82
  def failure?; end

  # Returns true for an instance of a {Try::Value} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/try.rb#76
  def success?; end

  # Returns self.
  #
  # @api public
  # @return [Try::Value, Try::Error]
  #
  # source://dry-monads//lib/dry/monads/try.rb#90
  def to_monad; end

  # Returns true for an instance of a {Try::Value} monad.
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/try.rb#76
  def value?; end

  class << self
    # Safely runs a block
    #
    # @api public
    # @example using Try with [] and a block (Ruby 2.5+)
    #   include Dry::Monads::Try::Mixin
    #
    #   def safe_db_call
    #   Try[DatabaseError] { db_call }
    #   end
    # @param exceptions [Array<Exception>]
    # @raise [ArgumentError]
    # @return [Try::Value, Try::Error]
    #
    # source://dry-monads//lib/dry/monads/try.rb#68
    def [](*exceptions, &block); end

    # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
    def lift(*args, &block); end

    # Wraps a value with Value
    #
    # @api public
    # @overload pure
    # @overload pure
    #
    # source://dry-monads//lib/dry/monads/try.rb#47
    def pure(value = T.unsafe(nil), exceptions = T.unsafe(nil), &block); end

    # Invokes a callable and if successful stores the result in the
    # {Try::Value} type, but if one of the specified exceptions was raised it stores
    # it in a {Try::Error}.
    #
    # @api public
    # @param exceptions [Array<Exception>] list of exceptions to rescue
    # @param f [#call] callable object
    # @return [Try::Value, Try::Error]
    #
    # source://dry-monads//lib/dry/monads/try.rb#28
    def run(exceptions, f); end
  end
end

# @api public
# @private
#
# source://dry-monads//lib/dry/monads/try.rb#11
Dry::Monads::Try::DEFAULT_EXCEPTIONS = T.let(T.unsafe(nil), Array)

# Represents a result of a failed execution.
#
# @api public
#
# source://dry-monads//lib/dry/monads/try.rb#179
class Dry::Monads::Try::Error < ::Dry::Monads::Try
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Monads::RightBiased::Left

  # @api public
  # @param exception [Exception]
  # @return [Error] a new instance of Error
  #
  # source://dry-monads//lib/dry/monads/try.rb#186
  def initialize(exception); end

  # @api public
  # @param other [Try]
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/try.rb#218
  def ===(other); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/try.rb#193
  def inspect; end

  # If a block is given passes internal value to it and returns the result,
  # otherwise simply returns the first argument.
  #
  # @api public
  # @example
  #   Try(ZeroDivisionError) { 1 / 0 }.or { "zero!" } # => "zero!"
  # @param args [Array<Object>] arguments that will be passed to a block
  #   if one was given, otherwise the first
  #   value will be returned
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/try.rb#208
  def or(*args); end

  # Acts in a similar way to `rescue`. It checks if
  # {exception} is one of {errors} and yields the block if so.
  #
  # @api public
  # @param errors [Class] List of Exception subclasses
  # @return [Try::Value]
  #
  # source://dry-monads//lib/dry/monads/try.rb#228
  def recover(*errors); end

  # @return [Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#425
  def to_maybe; end

  # @api private
  # @return [Result::Failure]
  #
  # source://dry-monads//lib/dry/monads/result.rb#452
  def to_result; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/try.rb#193
  def to_s; end

  class << self
    def call(*_arg0); end
  end
end

# A module that can be included for easier access to Try monads.
#
# @api public
# @example
#   class Foo
#   include Dry::Monads::Try::Mixin
#
#   attr_reader :average
#
#   def initialize(total, count)
#   @average = Try(ZeroDivisionError) { total / count }.value
#   end
#   end
#
#   Foo.new(10, 2).average # => 5
#   Foo.new(10, 0).average # => nil
#
# source://dry-monads//lib/dry/monads/try.rb#258
module Dry::Monads::Try::Mixin
  include ::Dry::Monads::Try::Mixin::Constructors

  # Error constructor
  #
  # @api public
  # @overload Error
  # @overload Error
  # @raise [ArgumentError]
  #
  # source://dry-monads//lib/dry/monads/try.rb#306
  def Error(error = T.unsafe(nil), &block); end

  # Value constructor
  #
  # @api public
  # @overload Value
  # @overload Value
  # @raise [ArgumentError]
  #
  # source://dry-monads//lib/dry/monads/try.rb#289
  def Value(value = T.unsafe(nil), exceptions = T.unsafe(nil), &block); end
end

# @api public
# @private
#
# source://dry-monads//lib/dry/monads/try.rb#263
module Dry::Monads::Try::Mixin::Constructors
  # A convenience wrapper for {Monads::Try.run}.
  # If no exceptions are provided it falls back to StandardError.
  # In general, relying on this behaviour is not recommended as it can lead to unnoticed
  # bugs and it is always better to explicitly specify a list of exceptions if possible.
  #
  # @api public
  # @param exceptions [Array<Exception>]
  # @return [Try]
  #
  # source://dry-monads//lib/dry/monads/try.rb#271
  def Try(*exceptions, &f); end
end

# @api public
# @see Dry::Monads::Try
#
# source://dry-monads//lib/dry/monads/try.rb#260
Dry::Monads::Try::Mixin::Try = Dry::Monads::Try

# Represents a result of a successful execution.
#
# @api public
#
# source://dry-monads//lib/dry/monads/try.rb#97
class Dry::Monads::Try::Value < ::Dry::Monads::Try
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Monads::RightBiased::Right

  # @api public
  # @param exceptions [Array<Exception>] list of exceptions to be rescued
  # @param value [Object] the value to be stored in the monad
  # @return [Value] a new instance of Value
  #
  # source://dry-monads//lib/dry/monads/try.rb#106
  def initialize(exceptions, value); end

  # Calls the passed in Proc object with value stored in self
  # and returns the result.
  #
  # If proc is nil, it expects a block to be given and will yield to it.
  #
  # @api public
  # @example
  #   success = Dry::Monads::Try::Value.new(ZeroDivisionError, 10)
  #   success.bind(->(n) { n / 2 }) # => 5
  #   success.bind { |n| n / 0 } # => Try::Error(ZeroDivisionError: divided by 0)
  # @param args [Array<Object>] arguments that will be passed to a block
  #   if one was given, otherwise the first
  #   value assumed to be a Proc (callable)
  #   object and the rest of args will be passed
  #   to this object along with the internal value
  # @return [Object, Try::Error]
  #
  # source://dry-monads//lib/dry/monads/try.rb#132
  def bind(*_arg0, **_arg1, &_arg2); end

  # @api public
  # @return [Array<Exception>] List of exceptions to rescue
  #
  # source://dry-monads//lib/dry/monads/try.rb#102
  def catchable; end

  # Does the same thing as #bind except it also wraps the value
  # in an instance of a Try monad. This allows for easier
  # chaining of calls.
  #
  # @api public
  # @example
  #   success = Dry::Monads::Try::Value.new(ZeroDivisionError, 10)
  #   success.fmap(&:succ).fmap(&:succ).value # => 12
  #   success.fmap(&:succ).fmap { |n| n / 0 }.fmap(&:succ).value # => nil
  # @param args [Array<Object>] extra arguments for the block, arguments are being processes
  #   just as in #bind
  # @return [Try::Value, Try::Error]
  #
  # source://dry-monads//lib/dry/monads/try.rb#150
  def fmap(*_arg0, **_arg1, &_arg2); end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/try.rb#157
  def inspect; end

  # Ignores values and returns self, see {Try::Error#recover}
  #
  # @api public
  # @param errors [Class] List of Exception subclasses
  # @return [Try::Value]
  #
  # source://dry-monads//lib/dry/monads/try.rb#171
  def recover(*_errors); end

  # @return [Maybe]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#418
  def to_maybe; end

  # @api private
  # @return [Result::Success]
  #
  # source://dry-monads//lib/dry/monads/result.rb#445
  def to_result; end

  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/try.rb#157
  def to_s; end

  private

  # @api public
  #
  # source://dry-monads//lib/dry/monads/right_biased.rb#42
  def bind_call(*args, **kwargs); end

  class << self
    def call(*_arg0); end

    # source://dry-monads//lib/dry/monads/right_biased.rb#15
    def to_proc; end
  end
end

# Unit is a special object you can use whenever your computations don't
# return any payload. Previously, if your function ran a side-effect
# and returned no meaningful value, you had to return things like
# Success(nil), Success([]), Success({}), Maybe(""), Success(true) and
# so forth.
#
# You should use Unit if you wish to return an empty monad.
#
# @api private
# @example with Result
#   Success(Unit)
#   Failure(Unit)
# @example with Maybe
#   Maybe(Unit)
#   => Some(Unit)
#
# source://dry-monads//lib/dry/monads/unit.rb#21
Dry::Monads::Unit = T.let(T.unsafe(nil), Object)

# An unsuccessful result of extracting a value from a monad.
#
# source://dry-monads//lib/dry/monads/errors.rb#6
class Dry::Monads::UnwrapError < ::StandardError
  # @return [UnwrapError] a new instance of UnwrapError
  #
  # source://dry-monads//lib/dry/monads/errors.rb#9
  def initialize(receiver); end

  # Returns the value of attribute receiver.
  #
  # source://dry-monads//lib/dry/monads/errors.rb#7
  def receiver; end
end

# @api private
# @see Validated::Valid
#
# source://dry-monads//lib/dry/monads/validated.rb#283
Dry::Monads::Valid = Dry::Monads::Validated::Valid

# Validated is similar to Result and represents an outcome of a validation.
# The difference between Validated and Result is that the former implements
# `#apply` in a way that concatenates errors. This means that the error type
# has to have `+` implemented (be a semigroup). This plays nice with arrays and lists.
# Also, List<Validated>#traverse implicitly uses a block that wraps errors with
# a list so that you don't have to do it manually.
#
# @api private
# @example using with List
#   List::Validated[Valid('London'), Invalid(:name_missing), Invalid(:email_missing)]
#   # => Invalid(List[:name_missing, :email_missing])
# @example with valid results
#   List::Validated[Valid('London'), Valid('John')]
#   # => Valid(List['London', 'John'])
#
# source://dry-monads//lib/dry/monads/validated.rb#20
class Dry::Monads::Validated
  # Bind/flat_map is not implemented
  #
  # @api private
  # @raise [NotImplementedError]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#48
  def bind(*_arg0); end

  # Returns self.
  #
  # @api private
  # @return [Validated::Valid, Validated::Invalid]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#42
  def to_monad; end

  class << self
    # Wraps a value with `Valid`.
    #
    # @api private
    # @overload pure
    # @overload pure
    #
    # source://dry-monads//lib/dry/monads/validated.rb#34
    def pure(value = T.unsafe(nil), &block); end
  end
end

# Invalid result
#
# @api private
#
# source://dry-monads//lib/dry/monads/validated.rb#140
class Dry::Monads::Validated::Invalid < ::Dry::Monads::Validated
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Invalid] a new instance of Invalid
  #
  # source://dry-monads//lib/dry/monads/validated.rb#154
  def initialize(error, trace = T.unsafe(nil)); end

  # @api private
  # @param other [Object]
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#222
  def ===(other); end

  # Lifts a block/proc over Invalid
  #
  # @api private
  # @overload alt_map
  # @overload alt_map
  #
  # source://dry-monads//lib/dry/monads/validated.rb#188
  def alt_map(proc = T.unsafe(nil), &block); end

  # Collects errors (ignores valid results)
  #
  # @api private
  # @overload apply
  # @overload apply
  #
  # source://dry-monads//lib/dry/monads/validated.rb#171
  def apply(val = T.unsafe(nil), &block); end

  # The value stored inside
  #
  # @api private
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#144
  def error; end

  # Ignores the passed argument and returns self
  #
  # @api private
  # @return [Validated::Invalid]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#196
  def fmap(_ = T.unsafe(nil)); end

  # @api private
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#215
  def inspect; end

  # Yields the given callable and returns the result
  #
  # @api private
  # @overload or
  # @overload or
  #
  # source://dry-monads//lib/dry/monads/validated.rb#210
  def or(proc = T.unsafe(nil), &block); end

  # Converts to Maybe::None
  #
  # @return [Maybe::None]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#445
  def to_maybe; end

  # Converts to Result::Failure
  #
  # @api private
  # @return [Result::Failure]
  #
  # source://dry-monads//lib/dry/monads/result.rb#472
  def to_result; end

  # @api private
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#215
  def to_s; end

  # Line where the value was constructed
  #
  # @api public
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#150
  def trace; end
end

# Mixin with Validated constructors
#
# @api private
#
# source://dry-monads//lib/dry/monads/validated.rb#229
module Dry::Monads::Validated::Mixin
  include ::Dry::Monads::Validated::Mixin::Constructors
end

# Actual constructor methods
#
# @api private
#
# source://dry-monads//lib/dry/monads/validated.rb#240
module Dry::Monads::Validated::Mixin::Constructors
  # Invalid constructor
  #
  # @api private
  # @overload Invalid
  # @overload Invalid
  # @raise [ArgumentError]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#268
  def Invalid(value = T.unsafe(nil), &block); end

  # Valid constructor
  #
  # @api private
  # @overload Valid
  # @overload Valid
  # @raise [ArgumentError]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#251
  def Valid(value = T.unsafe(nil), &block); end
end

# Unsuccessful validation result
#
# @api private
# @see Dry::Monads::Validated::Invalid
#
# source://dry-monads//lib/dry/monads/validated.rb#236
Dry::Monads::Validated::Mixin::Invalid = Dry::Monads::Validated::Invalid

# Successful validation result
#
# @api private
# @see Dry::Monads::Validated::Valid
#
# source://dry-monads//lib/dry/monads/validated.rb#232
Dry::Monads::Validated::Mixin::Valid = Dry::Monads::Validated::Valid

# Valid result
#
# @api private
#
# source://dry-monads//lib/dry/monads/validated.rb#56
class Dry::Monads::Validated::Valid < ::Dry::Monads::Validated
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Valid] a new instance of Valid
  #
  # source://dry-monads//lib/dry/monads/validated.rb#59
  def initialize(value); end

  # @api private
  # @param other [Object]
  # @return [Boolean]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#133
  def ===(other); end

  # Ignores values and returns self, see {Invalid#alt_map}
  #
  # @api private
  # @return [Validated::Valid]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#110
  def alt_map(_ = T.unsafe(nil)); end

  # Applies another Valid to the stored function
  #
  # @api private
  # @overload apply
  # @overload apply
  #
  # source://dry-monads//lib/dry/monads/validated.rb#88
  def apply(val = T.unsafe(nil), &block); end

  # Lifts a block/proc over Valid
  #
  # @api private
  # @overload fmap
  # @overload fmap
  #
  # source://dry-monads//lib/dry/monads/validated.rb#102
  def fmap(proc = T.unsafe(nil), &block); end

  # @api private
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#122
  def inspect; end

  # Ignores arguments, returns self
  #
  # @api private
  # @return [Validated::Valid]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#117
  def or(_ = T.unsafe(nil)); end

  # Converts to Maybe::Some
  #
  # @return [Maybe::Some]
  #
  # source://dry-monads//lib/dry/monads/maybe.rb#436
  def to_maybe; end

  # Converts to Result::Success
  #
  # @api private
  # @return [Result::Success]
  #
  # source://dry-monads//lib/dry/monads/result.rb#463
  def to_result; end

  # @api private
  # @return [String]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#122
  def to_s; end

  # Extracts the value
  #
  # @api private
  # @return [Object]
  #
  # source://dry-monads//lib/dry/monads/validated.rb#68
  def value!; end
end
